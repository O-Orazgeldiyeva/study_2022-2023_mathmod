# РОССИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ
## Факультет физико-математических и естественных наук


# Отчёт по лабораторной работе №1


**Дисциплина:** Операционные системы

**Студент:** Оразгелдиева Огулнур

**Группа:** НПИбд-02-20

***

**Лабораторная работа №1**

**Цель работы:** изучить идеологию и применение 
средств контроля версий git.

***

**Теоретические сведения**

Система контроля версий Git представляет собой набор программ командной строки.
Доступ к ним можно получить из терминала посредством ввода команды git с различными опциями.

Благодаря тому, что Git является распределённой системой контроля версий, резервную
копию локального хранилища можно сделать простым копированием или архивацией.

***

**Подготовка рабочего пространства**

Сначала нужно создать учётную запись на git (см. рис. 1)

![Рисунок 1. Аккаунт](https://i.imgur.com/J28fhEK.png)
Рисунок 1. Аккаунт

Далее в рабочем каталоге создаём каталоги (см. рис. 2)

![Рисунок 2. Создание каталогов](https://i.imgur.com/riX4vFG.png)
Рисунок 2. Создание каталогов

Перед началом работы нужно установить на нашей ОС git  (см. рис. 3)

![Рисунок 3. Установка git](https://i.imgur.com/aLB9vlF.png)
Рисунок 3. Установка git

Для последующей идентификации пользователя на сервере репозиториев необходимо
сгенерировать ssh-ключ (см. рис. 4)

![Рисунок 4. Генерация ключа](https://i.imgur.com/L1TSCqv.png)
Рисунок 4. Генерация ключа

Затем сгенерированнный ключ можно вручную вставить настройках на git (см. рис. 5-6)

![Рисунок 5. Сгенерированный ключ](https://i.imgur.com/z9i0dy2.png)
Рисунок 5. Сгенерированный ключ

![Рисунок 6. Сгенерированный ключ](https://i.imgur.com/PiKnvDC.png)
Рисунок 6. Сгенерированный ключ


Теперь нужно создать репозиторий. Сделаем это вручную на основе шаблона (см. рис. 7-8)

![Рисунок 7. Создание репозитория на основе шаблона](https://i.imgur.com/qiBlGVU.png)
Рисунок 7. Создание репозитория на основе шаблона

![Рисунок 8. Репозиторий](https://i.imgur.com/4dq73Xs.png)
Рисунок 8. Репозиторий

Затем клонируем содержимое репозитория в каталог matmod (см. рис. 9)

![Рисунок 9. Клонировние](https://i.imgur.com/vqEOrt9.png)
Рисунок 9. Клонировние

В созданном каталоге смотрим доступные цели (см. рис. 10)

![Рисунок 10. Доступные цели](https://i.imgur.com/A3rjSIM.png)
Рисунок 10. Доступные цели

Удалим лишние файлы (см. рис. 11)

![Рисунок 11. Удаление файла](https://i.imgur.com/87ncETs.png)
Рисунок 11. Удаление файла

Создадим необходимые каталоги (см. рис. 12)

![Рисунок 12. Создание каталога](https://i.imgur.com/IBuvaxK.png)
Рисунок 12. Создание каталога

Отправи файлы на сервер (см. рис. 13-14)

![Рисунок 13. Отправка файлов на сервер](https://i.imgur.com/oJj937z.png)
Рисунок 13. Отправка файлов на сервер

![Рисунок 14. Отправка файлов на сервер](https://i.imgur.com/OQn0BhY.png)
Рисунок 14. Отправка файлов на сервер

Проверили отправку файла (см. рис. 15)

![Рисунок 15. Отправка файла](https://i.imgur.com/Kb3Sx6t.png)
Рисунок 15. Отправка файла

***

**Ход работы:**

**1. Работа с git**

  **1.1 Подготовка**
  **Установка имени и электронной почты**
  
Для начала нам необходимо осуществить установку. Выполним следующие команды, чтобы git узнал наше имя и электронную почту (см. рис. 16)

![Рисунок 16. Имя и электронная почта](https://i.imgur.com/iBLaAdd.png)
Рисунок 16. Имя и электронная почта

**Параметры установки окончаний строк**

Настройка core.autocrlf с параметрами true и input делает все переводы
строк текстовых файлов в главном репозитории одинаковы.

core.autocrlf true - git автоматически конвертирует CRLF->LF при коммите и обратно LF->CRLF при выгрузке кода из репозитория на файловую систему
(используют в Windows). core.autocrlf input - конвертация CRLF в LF только
при коммитах (используют в Mac/Linux).

Если core.safecrlf установлен в true или warm, git проверяет, если преобразование является обратимым для текущей настройки core.autocrlf.
core.safecrlf true - отвержение необратимого преобразования lf<->crlf.
Полезно, когда специфические бинарники похожие на текстовые файлы.
core.safecrlf warn - печать только предупреждение, но принимает необратимый переход.

![Рисунок 17. Установка окончания строк](https://i.imgur.com/EvVJZea.png)
Рисунок 17. Установка окончания строк

**Установка отображения unicode**

По умолчанию, git будет печатать не-ASCII символов в именах файлов в виде
восьмеричных последовательностей \nnn. Что бы избежать нечитаемых строк,
установите соответствующий флаг (см. рис. 18)

![Рисунок 18. Установка отображения unicode](https://i.imgur.com/ae1vxE3.png)
Рисунок 18. Установка отображения unicode

**1.2 Создание проекта**

**Создайте страницу «Hello, World»**

Начните работу в пустом рабочем каталоге с создания пустого каталога с именем
hello, затем войдите в него и создайте там файл с именем hello.html.

![Рисунок 19. Создание файла](https://i.imgur.com/WFOhnip.png)
Рисунок 19. Создание файла

**Создание репозитория**

Чтобы создать git репозиторий из этого каталога, выполните команду git init.

![Рисунок 20. Создание репозитория](https://i.imgur.com/CagqpbJ.png)
Рисунок 20. Создание репозитория

**Добавление файла в репозиторий**

Добавим файл в репозиторий (см. рис. 21)

![Рисунок 21. Добавление файла](https://i.imgur.com/Nrltmlq.png)
Рисунок 21. Добавление файла

**Проверка состояние репозитория**

Используйте команду git status,чтобы проверитьтекущее состояние репози- тория (см. рис. 22)

![Рисунок 22. Проверка состояния](https://i.imgur.com/WCMMj8M.png)
Рисунок 22. Проверка состояния

Команда проверки состояния сообщит, что коммитить нечего. Это означает, что в репозитории хранится текущее состояние рабочего каталога,и нет никаких изменений,ожидающих записи.

**1.3 Внесение изменений**

**Измените страницу «Hello,World»**

Добавим кое-какие HTML-теги к нашему приветствию. Измените содержимое файла hello.html (см. рис. 23)

![Рисунок 23. Изменение файла](https://i.imgur.com/JxBOVxn.png)
Рисунок 23. Изменение файла

Проверьте состояние рабочего каталога (см. рис. 24)

![Рисунок 24. Проверка состояния](https://i.imgur.com/5lF17Vh.png)
Рисунок 24. Проверка состояния

git знает,что файл hello.html был изменен,но при этом эти изменения еще не зафиксированы в репозитории.

Также обратите внимание на то,что сообщение о состоянии дает вам подсказку о том,что нужно делатьдальше.Если вы хотите добавить эти изменения в репози- торий,используйте команду git add.В противном случае используйте команду git сheckout для отмены изменений.

**Индексация изменений**

Теперь выполните команду git,чтобы проиндексировать изменения.Проверьте состояние (см. рис. 25)

![Рисунок 25. Индексация изменений](https://i.imgur.com/uB0zLQe.png)
Рисунок 25. Индексация изменений

Изменения файла hello.html были проиндексированы.Это означает,что git те- перь знает об изменении,но изменение пока не записано в репозиторий.Следующий коммит будет включать в себя проиндексированные изменения.

Если вы решили,что не хотите коммитить изменения,команда состояния на- помнит вам о том,что с помощью команды git reset можно снять индексацию этих изменений.

Отдельный шаг индексациив git позволяетвампродолжатьвноситьизменения

в рабочий каталог, а затем, в момент, когда вы захотите взаимодействовать с версионным контролем, git позволит записать изменения в малых коммитах, которые фиксируютто,что вы сделали.

Разделяя индексацию и коммит,вы имеете возможность с легкостью настроить, что идет в какой коммит.

1. **Коммит изменений**

Когда вы ранее использовали git commit для коммита первоначальной версии файла hello.html в репозиторий, вы включили метку -m, которая делает ком- ментарий в командной строке.Команда commit позволит вам интерактивно ре- дактировать комментарии для коммита.Теперьдавайте это проверим.

Если вы опустите метку -m из командной строки, git перенесет вас в редак- тор по вашему выбору. Редактор выбирается из следующего списка (в порядке приоритета):

- переменная среды GIT\_EDITOR
- параметр конфигурации core.editor
- переменная среды VISUAL
- переменная среды EDITOR

Сделайте коммит и проверьте состояние (см. рис. 26-28)

![Рисунок 26. Коммит](https://i.imgur.com/0D7bwTm.png)
Рисунок 26. Коммит

![Рисунок 27. Коммит](https://i.imgur.com/2W1ugSO.png)
Рисунок 27. Коммит

![Рисунок 28. Проверка статуса](https://i.imgur.com/7g7zkOk.png)
Рисунок 28. Проверка статуса

Откроется редактор.

В первой строке введите комментарий: «Added h1 tag».Сохраните файл и вый- дите из редактора (для этого в редакторе по-умолчанию (Vim) вам нужно нажать клавишу ESC,ввести :wq и нажать Enter).

Теперь еще раз проверим состояние.

Рабочий каталог чистый,можно продолжить работу.

**Добавьте стандартные теги страницы**

Измените страницу «Hello,World»,чтобы она содержала стандартные теги (см. рис. 29)

![Рисунок 29. Изменение файла](https://i.imgur.com/yJ7PsXx.png)
Рисунок 29. Изменение файла

Теперь добавьте это изменение в индекс git (см. рис. 30)

![Рисунок 30. Добавление изменения](https://i.imgur.com/0zVaFlJ.png)

Рисунок 30. Добавление изменения

Теперь добавьте заголовки HTML к странице «Hello,World» (см. рис. 31)

![Рисунок 31. Изменение файла](https://i.imgur.com/q7K8sHl.png)
Рисунок 31. Изменение файла

Проверьте текущий статус: git status (см. рис. 32)

![Рисунок 32. Проверка статуса](https://i.imgur.com/DGbGlbE.png)
Рисунок 32. Проверка статуса

Обратите внимание на то, что hello.html указан дважды в состоянии. Пер- вое изменение (добавление стандартных тегов) проиндексировано и готово к коммиту.Второе изменение (добавление заголовков HTML) является непроиндек- сированным.Если бы вы делали коммит сейчас,заголовки не были бы сохранены в репозиторий.

Произведите коммит проиндексированного изменения (значение по умолча- нию),а затем еще раз проверьте состояние (см. рис. 33)

![Рисунок 33. Коммит](https://i.imgur.com/hiVnQ9V.png)

Рисунок 33. Коммит

Состояние команды говорит о том,что hello.html имеет незафиксированные изменения,но уже не в буферной зоне.

Теперь добавьте второе изменение в индекс, а затем проверьте состояние с помощью команды git status (см. рис. 34)

![Рисунок 34. Добавление изменений и проверка состояния](https://i.imgur.com/ljAfoOG.png)

Рисунок 34. Добавление изменений и проверка состояния

В качестве файла для добавления, мы использовали текущий каталог (.). Это краткийиудобныйпутьдлядобавлениявсехизмененийвфайлытекущегокаталога и его подкаталоги. Но поскольку он добавляет все, не лишним будет проверить состояние перед запуском add,просто чтобы убедиться,что вы не добавили какой- то файл,который добавлять было не нужно.

Второе изменение было проиндексировано и готово к коммиту.

Сделайте коммит второго изменения (см. рис. 35)

![Рисунок 35. Коммит](https://i.imgur.com/lBwz5qA.png)

Рисунок 35. Коммит


**История**

Получим список произведенных изменений (см. рис. 36)

![Рисунок 36. История](https://i.imgur.com/sO9Krrr.png)

Рисунок 36. История

Однострочный формат истории (см. рис. 37)

![Рисунок 37. История](https://i.imgur.com/Kv45rYa.png)

Рисунок 37. История

Есть много вариантов отображения лога (см. рис. 38)

![Рисунок 38. История](https://i.imgur.com/RJe15ZD.png)

Рисунок 38. История

Справочная страница (см. рис. 39)

![Рисунок 39. Справочная информация](https://i.imgur.com/08WQ463.png)

Рисунок 39. Справочная информация

Инструмент gitk полезен в изучении истории изменений.

**Получение старых версий**

Возвращаться назад в историю очень просто.Команда checkout скопируетлюбой снимок из репозитория в рабочий каталог.

Получите хэши предыдущих версий (см. рис. 38-39)

Изучите данные лога и найдите хэш для первого коммита. Он должен быть в последней строке данных.Используйте этот хэш-код (достаточно первых 7 знаков) в команде ниже.Затем проверьте содержимое файла hello.html (см. рис. 40)

![Рисунок 40. Содержимое файла](https://i.imgur.com/G3niAOs.png)

Рисунок 40. Содержимое файла

Вернитесь к последней версии в ветке master (см. рис. 41)

![Рисунок 41. Переключение ветки](https://i.imgur.com/oZjBRfz.png)

Рисунок 41. Переключение ветки

master —имя ветки по умолчанию.Переключая имена веток,вы попадаете на последнюю версию выбранной ветки.

**Создание тегов версий**

Давайте назовем текущую версию страницы hello первой (v1).

Создайте тег первой версии 

Теперь текущая версия страницы называется v1.

Теги для предыдущих версий Давайте создадим тег для версии, которая идет перед текущей версией и назовем его v1-beta.В первую очередь нам надо пере- ключиться на предыдущую версию.Вместо поиска до хэш,мы будем использовать

^, обозначающее «родитель v1». Вместо обозначения v1^ можно использовать v1~1.Это обозначение можно определить как «первую версию предшествующую

(см. рис. 42)

![Рисунок 42. Создание тега](https://i.imgur.com/8TH3kBO.png)

Рисунок 42. Создание тега

Это версия cтегами <html> и <body>,но еще пока без <head>.Давайте сделаем ее версией v1-beta (см. рис. 43):

git tag v1-beta

**Переключение по имени тега**

Теперь попробуйте попереключаться между двумя отмеченными версиями (см. рис. 44)

![Рисунок 44. Переключение между тегами](https://i.imgur.com/z1Xg6pA.png)

Рисунок 44. Переключение между тегами

**Просмотр тегов с помощью команды tag**

Вы можете увидеть,какие теги доступны,используя команду git tag (см. рис. 45)

![Рисунок 45. Доступные теги](https://i.imgur.com/bbTTx4y.png)

Рисунок 45. Доступные теги

Вы также можете посмотреть теги в логе (см. рис. 46)

![Рисунок 46. История](https://i.imgur.com/3DCgkSw.png)


Рисунок 46. История

Вы можете видетьтеги (v1 и v1-beta) в логе вместе с именем ветки (master). Кроме того HEAD показывает коммит,на который вы переключились (на данный момент это v1-beta).

**Отмена локальных изменений (до индексации)**

**Переключитесь на веткуmaster**

Убедитесь,что вы находитесь на последнем коммите ветки master,прежде чем продолжить работу (см. рис. 47)

![Рисунок 47. Переключение ветки](https://i.imgur.com/dYcyrcW.png)

Рисунок 47. Переключение ветки

**Измените hello.html**

Иногда случается, что вы изменили файл в рабочем каталоге, и хотите отменить последние коммиты. С этим справится команда git checkout.

Внесите изменение в файл hello.html в виде нежелательного комментария (см. рис. 48)

![Рисунок 48. Изменение файла](https://i.imgur.com/pshnKVV.png)

Рисунок 48. Изменение файла

**Проверьте состояние**

Сначала проверьте состояние рабочего каталога (см. рис. 49)

![Рисунок 49. Проверка состояния](https://i.imgur.com/t8kwsfg.png)

Рисунок 49. Проверка состояния

Мы видим,что файл hello.html был изменен,но еще не проиндексирован.

**Отмена изменений в рабочем каталоге**

Используйте команду git checkout для переключения версии файла hello.html в репозитории (см. рис. 50)

![Рисунок 50. Переключение версии](https://i.imgur.com/tAMkNGu.png)

Рисунок 50. Переключение версии

Команда git status показывает нам,что не было произведено никаких изме- нений,не зафиксированных в рабочем каталоге.

**Отмена проиндексированных изменений (перед коммитом)**

**Измените файл и проиндексируйте изменения**

Внесите изменение в файл hello.html в виде нежелательного комментария (см. рис. 51)

![Рисунок 51. Изменение файла](https://i.imgur.com/IKmyaeW.png)

Рисунок 51. Изменение файла

Проиндексируйте это изменение (см. рис. 52)

![Рисунок 52. Индексация](https://i.imgur.com/NkqKMQ2.png)

Рисунок 52. Индексация

**Проверьте состояние**

Проверьте состояние нежелательного изменения (см. рис. 52)

Состояние показывает,что изменение было проиндексировано и готово к ком- миту.

**Выполните сброс буферной зоны**

К счастью,вывод состояния показывает нам именно то,что мы должны сделать для отмены индексации изменения (см. рис. 53)

![Рисунок 53. Отмена изменений](https://i.imgur.com/9c5zv24.png)

Рисунок 53. Отмена изменений

Команда git reset сбрасывает буферную зону к HEAD.Это очищает буферную зону от изменений,которые мы только что проиндексировали.

Команда git reset (по умолчанию) не изменяет рабочий каталог. Поэтому рабочий каталог все еще содержит нежелательный комментарий.Мы можем ис- пользовать команду git checkout,чтобы удалить нежелательные изменения в рабочем каталоге.

**Переключитесь на версию коммита**

Наш рабочий каталог опять чист (см. рис. 54)

![Рисунок 54. Проверка статуса](https://i.imgur.com/KcgdeYH.png)

Рисунок 54. Проверка статуса

**Отмена коммитов**
**Отмена коммитов**

Иногда вы понимаете, что новые коммиты являются неверными, и хотите их отменить.Естьнесколько способов решения этого вопроса,здесьмы будем исполь- зовать самый безопасный.

Мы отменим коммит путем создания нового коммита, отменяющего нежела- тельные изменения.

**Измените файл и сделайте коммит**

Измените файл hello.html на следующий (см. рис. 55)

![Рисунок 55. Изменение файла](https://i.imgur.com/W0NiwkT.png)

Рисунок 55. Изменение файла

Выполните (см. рис. 56)

![Рисунок 56. Коммит](https://i.imgur.com/s8SvqJS.png)

Рисунок 56. Коммит


**Сделайте коммит с новыми изменениями,отменяющими предыдущие**

Чтобы отменить коммит,нам необходимо сделать коммит,который удаляет изме- нения,сохраненные нежелательным коммитом

Перейдите в редактор,где вы можете отредактировать коммит-сообщение по умолчанию или оставить все как есть. Сохраните и закройте файл.

Так как мы отменили самый последний произведенный коммит, мы смогли использовать HEAD в качестве аргумента для отмены. Мы можем отменитьлюбой произвольной коммит в истории,указав его хэш-значение.

**Проверьте лог**

Проверка лога показывает нежелательные и отмененные коммиты в наш репози- торий (см. рис.57)

![Рисунок 57. История](https://i.imgur.com/nOV252Z.png)

Рисунок 57. История

Эта техника будет работать с любым коммитом.

**Удаление коммиттов из ветки**

git revert является мощной командой,которая позволяетотменитьлюбые ком- миты в репозиторий.Однако,и оригинальный и «отмененный» коммиты видны в истории ветки (при использовании команды git log).

Часто мы делаем коммит, и сразу понимаем, что это была ошибка. Было бы неплохо иметь команду «возврата», которая позволила бы нам сделать вид, что неправильного коммита никогда и не было.Команда «возврата» даже предотвра- тила бы появление нежелательного коммита в истории git log.

**Команда git reset**

При получении ссылки на коммит (т.е. хэш, ветка или имя тега), команда git reset:

- перепишеттекущую ветку,чтобы она указывала на нужный коммит;
- опционально сбросит буферную зону для соответствия с указанным комми- том;
- опционально сбросит рабочий каталогдля соответствия с указанным комми- том.
**Проверьте нашу историю**

Давайте сделаем быструю проверку нашей истории коммитов (см. рис. 58)

![Рисунок 58. История](https://i.imgur.com/q7SPxbB.png)

Рисунок 58. История

Мы видим,что два последних коммита в этой ветке—«Oops» и «Revert Oops». Давайте удалим их с помощью сброса.

**Для начала отметьте эту ветку**

Но прежде чем удалить коммиты, давайте отметим последний коммит тегом,чтобы потом можно было его найти (см. рис. 59)


**Сброс коммитов к предшествующим коммитуOops**

Глядя на историю лога, мы видим, что коммит с тегом «v1» является коммитом, предшествующим ошибочному коммиту. Давайте сбросим ветку до этой точки. Поскольку ветка имеет тег, мы можем использовать имя тега в команде сброса (если она не имееттега,мы можем использовать хэш-значение) (см. рис. 59)

![Рисунок 59. Сброс коммита](https://i.imgur.com/by3vc4t.png)

Рисунок 59. Сброс коммита

Наша ветка master теперь указывает на коммит v1, а коммитов Oops и Revert Oops в ветке уже нет. Параметр --hard указывает, что рабочий каталог должен быть обновлен в соответствии с новым head ветки.

**Ничего никогда не теряется**

Что же случается с ошибочными коммитами? Оказывается,что коммиты все еще находятся в репозитории. На самом деле, мы все еще можем на них ссылаться. Помните,в начале этого урока мы создали для отмененного коммита тег «oops». Давайте посмотрим на все коммиты (см. рис. 60)

![Рисунок 60. История всех коммитов](https://i.imgur.com/HexZdGG.png)

Рисунок 60. История всех коммитов

Мы видим, что ошибочные коммиты не исчезли. Они все еще находятся в ре- позитории. Просто они отсутствуют в ветке master. Если бы мы не отметили их тегами,они по-прежнему находились бы в репозитории,но не было бы никакой возможности ссылаться на них,кроме как при помощи их хэш имен.Коммиты,на которые нет ссылок,остаются в репозитории до тех пор,пока не будет запущен сборщик мусора.

**Опасность сброса**

Сброс в локальных ветках,как правило,безопасен.Последствия любой «аварии» как правило,можно восстановить простым сбросом с помощью нужного коммита. Однако,если ветка «расшарена» на удаленных репозиториях,сброс может сбить с толку других пользователей ветки.

**Удаление тега oops**

**Удаление тега oops**

Тег oops свою функцию выполнил.Давайте удалим его и коммиты,на которые он ссылался,сборщиком мусора (см. рис. 61)

![Рисунок 61. Удаление тега](https://i.imgur.com/JeqcUSM.png)

Рисунок 61. Удаление тега

Тег «oops» больше не будет отображаться в репозитории.

**Внесение изменений в коммиты**
**Измените страницу,а затем сделайте коммит**

Добавьте в страницу комментарий автора (вставьте свою фамилию) (см. рис. 62)

![Рисунок 62. Изменение файла](https://i.imgur.com/bxLBKIY.png)

Рисунок 62. Изменение файла

Выполните (см. рис. 63)

![Рисунок 63. Коммит](https://i.imgur.com/JxTlRGF.png)

Рисунок 63. Коммит

**Необходим email**

После совершения коммита вы понимаете,что любой хороший комментарий дол- жен включать электронную почту автора.Обновите страницу hello,включив в нее email (см. рис. 64)

![Рисунок 64. Изменение файла](https://i.imgur.com/5BKbKYE.png)

Рисунок 64. Изменение файла

**Измените предыдущий коммит**

Мы действительно не хотим создавать отдельный коммит только ради электронной почты. Давайте изменим предыдущий коммит, включив в него адрес электронной почты (см. рис. 64)

![Рисунок 64. Коммит](https://i.imgur.com/G4Mnnju.png)

Рисунок 64. Коммит

**Просмотр истории**

Выполните (см. рис. 65)

![Рисунок 65. История](https://i.imgur.com/D9kPOAB.png)

Рисунок 65. История

Мы можем увидеть,что оригинальный коммит «автор» заменен коммитом «ав- тор/email».Этого же эффекта можно достичь путем сброса последнего коммита в ветке,и повторного коммита новых изменений.

**Перемещение файлов**

**Переместите файл hello.html в каталог lib**

Сейчас мы собираемся создать структуру нашего репозитория.Давайте перенесем страницу в каталог lib (см. рис. 66)

![Рисунок 66. Перемещение файла](https://i.imgur.com/VvV4hiY.png)

Рисунок 66. Перемещение файла

Перемещая файлы с помощью git mv,мы информируем git о 2 вещах:

- Что файл hello.html был удален.
- Что файл lib/hello.html был создан.
- Оба эти факта сразу же проиндексированы и готовы к коммиту.Команда git status сообщает,что файл был перемещен.

**Второй способ перемещения файлов**

Положительной чертой git является то,что вы можете забыть о версионном кон- троле до того момента,когда вы готовы приступить к коммиту кода.Что бы слу- чилось,если бы мы использовали командную строку операционной системы для перемещения файлов вместо команды git?

Следующий набор команд идентичен нашим последним действиям. Работы здесь побольше,но результаттот же.

Мы могли бы выполнить:

mkdir lib

mv hello.html lib

git add lib/hello.html git rm hello.html

**Коммит в новый каталог**

Давайте сделаем коммит этого перемещения (см. рис. 67)

![Рисунок 67. Коммит](https://i.imgur.com/1apyzcZ.png)

Рисунок 67. Коммит

**Подробнее о структуре**

**Добавление index.html**

Добавим файл index.html в наш репозиторий (см. рис. 68)

![Рисунок 68. Изменение файла](https://i.imgur.com/bJF1meO.png)

Рисунок 68. Изменение файла

Добавьте файл и сделайте коммит (см. рис. 69)

![Рисунок 69. Коммит](https://i.imgur.com/Z6HLJu2.png)

Рисунок 69. Коммит

Теперь при открытии index.html,вы должны увидеть кусок страницы hello в маленьком окошке (см. рис. 70)

![Рисунок 70. Открытие файла](https://i.imgur.com/ggV0kH9.png)

Рисунок 70. Открытие файла

**Git внутри: Каталог.git**
**Каталог.git**

Выполните (см. рис. 71)

![Рисунок 71. Содержимое каталога](https://i.imgur.com/0qARnlA.png)

Рисунок 71. Содержимое каталога

Это каталог,в котором хранится вся информация git.

**База данных объектов**

Выполните (см. рис. 72)

![Рисунок 72. Содержимое каталога](https://i.imgur.com/2ZphtYL.png)

Рисунок 72. Содержимое каталога

Вы должны увидеть набор каталогов,имена которых состоятиз 2 символов.Име- на каталогов являются первыми двумя буквами хэша sha1 объекта,хранящегося в git.

**Углубляемся в базу данных объектов**

Выполните (см. рис. 73)

![Рисунок 73. Содержимое каталога](https://i.imgur.com/iXDLHVC.png)

Рисунок 73. Содержимое каталога

Смотрим в один из каталогов с именем из 2 букв.Вы увидите файлы с именами из 38 символов.Это файлы,содержащие объекты,хранящиеся в git.Они сжаты и закодированы,поэтому просмотр их содержимого нам мало чем поможет.

**Config File**

Выполните (см. рис. 74)

![Рисунок 74. Файл конфигурации](https://i.imgur.com/BQTmWD8.png)

Рисунок 74. Файл конфигурации

Это файл конфигурации, создающийся для каждого конкретного проекта. Записи в этом файле будут перезаписывать записи в файле .gitconfig вашего главного каталога,по крайней мере в рамках этого проекта.

**Ветки и теги**

Выполните (см. рис. 75)

![Рисунок 75. Ветки и теги](https://i.imgur.com/FfqxjWK.png)

Рисунок 75. Ветки и теги

Вы должны узнавать файлы в подкаталоге тегов. Каждый файл соответствует тегу,ранее созданному с помощью команды git tag.Его содержание—это всего лишь хэш коммита,привязанный к тегу.

Каталог heads практически аналогичен,но используется для веток,а не тегов. На данный момент у нас естьтолько одна ветка,так что все,что вы увидите в этом каталоге–это ветка master.

**Файл HEAD**

Выполните (см. рис. 76)

![Рисунок 76. Файл HEAD](https://i.imgur.com/K63QkRd.png)

Рисунок 76. Файл HEAD

Файл HEADсодержит ссылку на текущую ветку, в данный момент это должна быть ветка master.

**Работа непосредственно с объектами git**

**Поиск последнего коммита**

Выполните (см. рис. 77)

![Рисунок 77. Коммит](https://i.imgur.com/Yq6of2Z.png)

Рисунок 77. Коммит

Эта команда должна показать последний коммит в репозиторий. SHA1 хэш в вашей системе,вероятно,отличается от моего,но вы увидите что-то наподобие этого.

**Вывод последнего коммита с помощью SHA1 хэша**

Выполните (см. рис. 78)

![Рисунок 78. Коммит](https://i.imgur.com/vpiOWUG.png)

Рисунок 78. Коммит


**Поиск дерева**

Мы можем вывести дерево каталогов, ссылка на который идет в коммите. Это должно быть описание файлов (верхнего уровня) в нашем проекте (для конкретного коммита). Используйте SHA1 хэш из строки «дерева»,из списка выше.

Выполните (см. рис. 79)

![Рисунок 79. Поиск дерева](https://i.imgur.com/r6huPlw.png)

Рисунок 79. Поиск дерева

**Вывод каталога lib** 

Выполните (см. рис. 80)

![Рисунок 80. Каталог lib](https://i.imgur.com/Ba6zQVt.png)

Рисунок 80. Каталог lib


**Исследуйте самостоятельно**

Исследуйте git репозиторий вручную самостоятельно. Смотрите, удастся ли вам найти оригинальный файл hello.html с самого первого коммита вручную по ссылкам SHA1 хэша в последнем коммите.

**Создание ветки**

Пора сделать наш hello world более выразительным. Так как это может занять некоторое время, лучше переместить эти изменения в отдельную ветку, чтобы изолировать их от изменений в ветке master.

**Создайте ветку**

Давайте назовем нашу новую ветку «style» (см. рис. 81)

![Рисунок 81. Ветка](https://i.imgur.com/SHQm4GW.png)

Рисунок 81. Ветка

git checkout -b <имя\_ветки> является шорткатом для git branch <имя\_ветки> за которым идет git checkout <имя\_ветки>.

Обратите внимание,что команда git status сообщает о том,что вы находи- тесь в ветке «style».

**Добавьте файл стилей style.css**

Файл lib/style.css (см. рис. 82)  

![Рисунок 82. Изменение файла](https://i.imgur.com/TXvQzoO.png)

Рисунок 82. Изменение файла

Выполните (см. рис. 83)

![Рисунок 83. Добавление индексации и коммита](https://i.imgur.com/7vThX94.png)

Рисунок 83. Добавление индексации и коммита

**Измените основную страницу**

Обновите файл hello.html,чтобы использовать стили style.css (см. рис. 84)

![Рисунок 84. Изменение файла](https://i.imgur.com/qkMhWn3.png)

Рисунок 84. Изменение файла

Выполните (см. рис. 85)

![Рисунок 85. Коммит](https://i.imgur.com/HbIqx1U.png)

Рисунок 85. Коммит


**Измените index.html**

Обновите файл index.html,чтобы он тоже использовал style.css (см. рис. 86)

![Рисунок 86. Изменение файла](https://i.imgur.com/L6LDvvj.png)

Рисунок 86. Изменение файла

Выполните (см. рис. 87)

![Рисунок 87. Коммит](https://i.imgur.com/87CG6BA.png)

Рисунок 87. Коммит

**Навигация по веткам**

Теперь в вашем проекте есть две ветки:

Выполните (см. рис. 88)

![Рисунок 88. История всех коммитов](https://i.imgur.com/4W5XyVq.png)

Рисунок 88. История всех коммитов

**Переключение на веткуmaster**

Используйте команду git checkout для переключения между ветками (см. рис. 89)

![Рисунок 89. Переключение между ветками](https://i.imgur.com/IUu0F0h.png)

Рисунок 89. Переключение между ветками

Сейчас мы находимся на ветке master. Это заметно по тому, что файл hello.html не использует стили style.css.

**Вернемся к ветке style**

Выполните (см. рис. 90)

git checkout style cat lib/hello.html

![Рисунок 90. Переключение между ветками](https://i.imgur.com/fukp8fd.png)

Рисунок 90. Переключение между ветками

Содержимое lib/hello.html подтверждает,что мы вернулись на ветку style.

**Изменения в ветке master**

Пока вы меняли ветку style,кто-то решил обновить ветку master. Они добавили файл README.md.

**Создайте файл READMEв веткеmaster**

Создайте файл README.md (см. рис. 91)

![Рисунок 91. Создание файла README](https://i.imgur.com/HmDxe8y.png)

Рисунок 91. Создание файла README

**Сделайте коммит изменений README.mdв ветку master .**

Выполните (см. рис. 92)

![Рисунок 92. Коммит](https://i.imgur.com/KEs7tvN.png)

Рисунок 92. Коммит

**Просмотр отличающихся веток**
**Просмотрите текущие ветки**

Теперь у нас в репозитории есть две отличающиеся ветки. Используйте следующую лог-команду для просмотра веток и их отличий.

Выполните (см. рис. 93)

![Рисунок 93. Просмотр веток](https://i.imgur.com/jJyGxWb.png)

Рисунок 93. Просмотр веток

Добавление опции --graph в git log вызывает построение дерева коммитов с помощью простых ASCII символов. Мы видим обе ветки (style и master), и то, что ветка master является текущей HEAD.Общим предшественником обеих веток является коммит «Added index.html».

Опция --all гарантированно означает,что мы видим все ветки.По умолчанию показывается только текущая ветка.

**Слияние**

**Слияние веток**

Слияние переносит изменения из двух веток в одну. Давайте вернемся к ветке style и сольем master с style.

Выполните (см. рис. 94)

git checkout style git merge master git log --graph --all

![Рисунок 94. Просмотр веток](https://i.imgur.com/icnEODJ.png)

Рисунок 94. Просмотр веток

Путем периодического слияния ветки master с веткой style вы можете переносить из master любые изменения и поддерживать совместимость изменений style с изменениями в основной ветке.

Но что если изменения в ветке master конфликтуют с изменениями в style?

**Создание конфликта**

**Вернитесь в master и создайте конфликт**

Вернитесь в ветку master и внесите следующие изменения (см. рис. 95)

![Рисунок 95. Переключение между ветками](https://i.imgur.com/3o9BKKM.png)

Рисунок 95. Переключение между ветками

Файл lib/hello.html (см. рис. 96)

![Рисунок 96. Изменение файла](https://i.imgur.com/pphkxqX.png)

Рисунок 96. Изменение файла

Выполните (см. рис. 97)

![Рисунок 97. Коммит](https://i.imgur.com/1UGglFy.png)

Рисунок 97. Коммит

**Просмотр веток**

Выполните (см. рис. 98)

![Рисунок 98. Просмотр веток](https://i.imgur.com/OZtyNwe.png)

Рисунок 98. Просмотр веток

После коммита «Added README» ветка master была объединена с веткой style, но в настоящее время в master естьдополнительный коммит,который не был слит с style.

Последнее изменение в master конфликтует с некоторыми изменениями в style.На следующем шаге мы решим этот конфликт.

**Разрешение конфликтов**
**Слияние master с веткой style**

Теперь вернемся к ветке style и попытаемся объединить ее с новой веткой master.

Выполните (см. рис. 99)

![Рисунок 99. Слияние веток](https://i.imgur.com/30nWSfw.png)

Рисунок 99. Слияние веток

Если вы откроете lib/hello.html,вы увидите (см. рис. 100)

![Рисунок 100. Содержимое файла](https://i.imgur.com/p6cOyEm.png)

Рисунок 100. Содержимое файла

Первый раздел—версия текущей ветки (style).Второй раздел—версия ветки
 master.

**Решение конфликта**

Вам необходимо вручную разрешить конфликт. Внесите изменения в lib/hello.html для достижения следующего результата (см. рис. 101)

![Рисунок 101. Изменение файла](https://i.imgur.com/tmlbr3I.png)

Рисунок 101. Изменение файла

**Сделайте коммит решения конфликта**

Выполните (см. рис. 102)

![Рисунок 102. Коммит](https://i.imgur.com/ere3DuU.png)

Рисунок 102. Коммит

**Перебазирование как альтернатива слиянию**

Рассмотрим различия между слиянием и перебазированием.Для того,чтобы это сделать,нам нужно вернуться в репозиторий в моментдо первого слияния,а затем повторитьте же действия,но с использованием перебазирования вместо слияния.

Мы будем использовать команду reset для возврата веток к предыдущему состоянию.

**Сброс ветки style**
**Сброс ветки style**

Вернемся на ветке style к точке перед тем,как мы слили ее с веткой master.Мы можем сбросить ветку к любому коммиту.По сути,это изменение указателя ветки на любую точку дерева коммитов.

Вэтомслучаемыхотимвернутьсявветке style вточкупередслияниемсmaster. Нам необходимо найти последний коммит перед слиянием.

Выполните (см. рис. 103)

![Рисунок 103. Просмотр веток](https://i.imgur.com/1UmA0gE.png)

Рисунок 103. Просмотр веток

Мы видим, что коммит «Updated index.html» был последним на ветке style перед слиянием.Давайте сбросим ветку style к этому коммиту.

Выполните (см. рис. 104)

![Рисунок 104. Сброс](https://i.imgur.com/XxZlt5Q.png)

Рисунок 104. Сброс

**Проверьте ветку.**

Поищите лог ветки style.У нас в истории больше нет коммитов слияний.

Выполните (см. рис. 105)

![Рисунок 106. Просмотр веток](https://i.imgur.com/Iq1EGmR.png)

Рисунок 106. Просмотр веток

**Сброс веткиmaster**

**Сброс ветки master**

Добавив интерактивный режим в ветку master,мы внесли изменения,конфлик- тующие с изменениями в ветке style.Давайте вернемся в ветке master в точку перед внесением конфликтующих изменений.Это позволяет нам продемонстри- ровать работу команды git rebase,не беспокоясь о конфликтах.

Выполните (см. рис. 107)

![Рисунок 107. Просмотр веток](https://i.imgur.com/lo1FVPZ.png)

Рисунок 107. Просмотр веток

Коммит «Added README» идет непосредственно перед коммитом конфлик- тующего интерактивного режима. Мы сбросим ветку master к коммиту «Added README».

Выполните (см. рис. 108)

![Рисунок 108. Сброс и просмотр веток](https://i.imgur.com/AbFoMZk.png)

Рисунок 108. Сброс и просмотр веток

Просмотрите лог. Он должен выглядеть,как будто репозиторий был перемотан назад во времени к точке до какого-либо слияния.

**Перебазирование**

Используем команду rebase вместо команды merge. Мы вернулись в точку до первого слияния и хотим перенести изменения из ветки master в нашу ветку style. На этот раз для переноса изменений из ветки master мы будем использовать команду git rebase вместо слияния.

Выполните (см. рис. 109)

![Рисунок 109. Перебазировнание](https://i.imgur.com/DeFytTC.png)

Рисунок 109. Перебазировнание

**Слияние VS перебазирование**

Конечный результат перебазирования очень похож на результат слияния. Ветка style в настоящее время содержит все свои изменения, а также все изменения ветки master. Однако, дерево коммитов значительно отличается. Дерево ком- митов ветки style было переписано таким образом, что ветка master является частью истории коммитов.Это делает цепь коммитов линейной и гораздо более читабельной.

Не используйте перебазирование:

- если ветка является публичной и расшаренной,поскольку переписывание общих веток будет мешать работе других членов команды;
- когда важна точная история коммитов ветки,так как команда rebase перепи- сывает историю коммитов;

Учитывая приведенные выше рекомендации,рекомендуется использовать git rebase для кратковременных,локальных веток,а слияние для веток в публичном репозитории.

**Слияние в ветку master**

Мы поддерживали соответствие ветки style с веткой master (с помощью rebase), теперьдавайте сольем изменения style в ветку master.

**Слияние style в master**

Выполните (см. рис. 110)

![Рисунок 110. Слияние веток](https://i.imgur.com/0LsMqHf.png)

Рисунок 110. Слияние веток

Поскольку последний коммит ветки master прямо предшествует последнему коммиту ветки style, git может выполнить ускоренное слияние-перемотку.При быстрой перемотке вперед git просто передвигает указатель вперед,таким обра- зом указывая на тот же коммит,что и ветка style.

При быстрой перемотке конфликтов быть не может.

**Просмотрите логи**

Выполните (см. рис. 111)

![Рисунок 111. Просмотр логов](https://i.imgur.com/RyYzB2b.png)

Рисунок 111. Просмотр логов

Теперь ветки style и master идентичны.

**Клонирование репозиториев**

**Перейдите в рабочий каталог**

Перейдите в рабочий каталог и сделайте клон вашего репозитория hello (см. рис. 112)

![Рисунок 112. Переход в каталог](https://i.imgur.com/fig6FtI.png)

Рисунок 112. Переход в каталог

Сейчас мы находимся в рабочем каталоге.

В этот момент вы должны находиться в «рабочем» каталоге.Здесьдолжен быть единственный репозиторий под названием «hello».

**Создайте клон репозитория hello**

Создадим клон репозитория.

Выполните (см. рис. 113)

![Рисунок 113. Создание клона](https://i.imgur.com/DqA21A8.png)

Рисунок 113. Создание клона

В вашем рабочем каталоге теперь должно быть два репозитория: оригинальный репозиторий «hello» и клонированный репозиторий «cloned\_hello»

**Просмотр клонированного репозитория**

**Давайте взглянем на клонированный репозиторий.**

Выполните (см. рис. 114)

![Рисунок 114. Переход к каталог](https://i.imgur.com/pu4PQuT.png)

Рисунок 114. Переход к каталог

Вы увидите список всех файлов на верхнем уровне оригинального репозитория README.md, index.html и lib.

**Просмотрите историю репозитория**

Выполните (см. рис. 115)

![Рисунок 115. Просмотр истории репозиториев](https://i.imgur.com/VEC2Mbg.png)

Рисунок 115. Просмотр истории репозиториев

Вы увидите список всех коммитов в новый репозиторий,и он должен (более или менее) совпадать с историей коммитов в оригинальном репозитории.Единствен- ная разница должна быть в названиях веток.

**Удаленные ветки**

Вы увидите ветку master (HEAD) в списке истории. Вы также увидите ветки со странными именами (origin/master,origin/style и origin/HEAD).

**Что такое origin?**

Выполните (см. рис. 116)

![Рисунок 116. Удаленная ветка](https://i.imgur.com/NsMnQ4e.png)

Рисунок 116. Удаленная ветка

Мы видим, что клонированный репозиторий знает об имени по умолчанию удаленного репозитория.Давайте посмотрим,можем ли мы получить более по- дробную информацию об имени по умолчанию:

Выполните (см. рис. 117)

![Рисунок 117. Удаленная ветка](https://i.imgur.com/2pQo9q0.png)

Рисунок 117. Удаленная ветка

Удаленные репозитории обычно размещаются на отдельной машине, возможно, централизованном сервере. Однако,как мы видим здесь,они могут с тем же успехом указывать на репозиторий на той же машине. Нет ничего особенного в имени «origin», однако существует традиция использовать «origin» в качестве имени первичного централизованного репозитория (если таковой имеется).

**Удаленные ветки**

Давайте посмотрим на ветки,доступные в нашем клонированном репозитории.

Выполните (см. рис. 118)

![Рисунок 118. Ветки](https://i.imgur.com/BdCmYGH.png)

Рисунок 118. Ветки

Как мы видим, в списке только ветка master. Где ветка style? Команда git branch выводиттолько список локальных веток по умолчанию.

**Список удаленных веток**

Для того,чтобы увидеть все ветки,попробуйте следующую команду (см. рис. 119)

![Рисунок 119. Удаленные ветки](https://i.imgur.com/Ax8DtBX.png)

Рисунок 119. Удаленные ветки

Git выводит все коммиты в оригинальный репозиторий,но ветки в удаленном репозиториинерассматриваютсякаклокальные.Еслимыхотимсобственнуюветку style,мы должны сами ее создать.Через минуту вы увидите,как это делается.

**Изменение оригинального репозитория**

Внесите некоторые изменения в оригинальный репозиторий,чтобы затем попы- таться извлечь и слить изменения из удаленной ветки в текущую

**Внесите изменения в оригинальный репозиторий hello**

Выполните: (см. рис. 120)

![Рисунок 120. Переход в каталог](https://i.imgur.com/LlCOwb2.png)

Рисунок 120. Переход в каталог

Примечание: Сейчас мы находимся в репозитории hello Внесите следующие изменения в файл README.md (см. рис. 121)

This is the Hello World example from the git tutorial.

![Рисунок 121. Изменение файла](https://i.imgur.com/Gdz1Hpg.png)

Рисунок 121. Изменение файла

Теперь добавьте это изменение и сделайте коммит 

Выполните (см. рис. 122)

![Рисунок 122. Коммит](https://i.imgur.com/l6fW2SO.png)

Рисунок 122. Коммит

Теперь в оригинальном репозитории есть более поздние изменения,которых нет в клонированной версии.Далее мы извлечем и сольем эти изменения в клони- рованный репозиторий.

**Извлечение изменений**

Научиться извлекать изменения из удаленного репозитория.

Выполните (см. рис. 123)

![Рисунок 123. Изменения](https://i.imgur.com/TVkbZj9.png)

Рисунок 123. Изменения

Сейчас мы находимся в репозитории cloned\_hello.

На данный момент в репозитории есть все коммиты из оригинального репози- тория,но они не интегрированы в локальные ветки клонированного репозитория.

В истории выше найдите коммит «Changed README in original repo».Обратите внимание,что коммит включает в себя коммиты «origin/master» и «origin/HEAD».

Теперь давайте посмотрим на коммит «Updated index.html». Вы увидите, что локальная ветка master указывает на этот коммит,а не на новый коммит,который мы только что извлекли.

Выводом является то, что команда git fetch будет извлекать новые комми- ты из удаленного репозитория,но не будет сливать их с вашими наработками в локальных ветках.

**Проверьте README.md**

Мы можем продемонстрировать, что клонированный файл README.md не изменился.

Выполните (см. рис. 124)

![Рисунок 124. Содержимое файла](https://i.imgur.com/pNFZ2EL.png)

Рисунок 124. Содержимое файла

**Слияние извлеченных изменений**

**Слейте извлеченные изменения в локальную ветку master** 

Выполните (см. рис. 125)

![Рисунок 125. Слияние изменений](https://i.imgur.com/d47LFjM.png)

Рисунок 125. Слияние изменений

**Еще раз проверьте файл README.md**

Сейчас мы должны увидеть изменения.

Выполните (см. рис. 126)

![Рисунок 126. Изменения](https://i.imgur.com/mELq0BR.png)

Рисунок 126. Изменения

Хотя команда git fetch не сливает изменения, мы можем вручную слить из- менения из удаленного репозитория.

Теперь давайте рассмотрим объединение fetch и merge в одну команду. Выполнение git pull эквивалентно двум следующим шагам git fetch и git merge origin/master

**Добавление ветки наблюдения**

Ветки, которые начинаются с remotes/origin являются ветками оригинального репозитория. Обратите внимание, что у вас больше нет ветки под названием style, но система контроля версий знает,что в оригинальном репозитории ветка style была.

**Добавьте локальную ветку,которая отслеживает удаленную ветку**

Выполните (см. рис. 127-128)

![Рисунок 127. Добавление ветки](https://i.imgur.com/CvF8I3d.png)

Рисунок 127. Добавление ветки

![Рисунок 128. Добавление ветки](https://i.imgur.com/DKzVib8.png)

Рисунок 128. Добавление ветки

Теперь мы можем видеть ветку style в списке веток и логе.

**Чистые репозитории**

Чистые репозитории (без рабочих каталогов) обычно используются для расшаривания. Обычный git-репозиторий подразумевает, что вы будете использовать его как рабочую директорию, поэтому вместе с файлами проекта в актуальной версии,git хранит все служебные,«чисто-репозиториевские» файлы в поддиректории.git. В удаленных репозиториях нет смысла хранить рабочие файлы на диске (как это делается в рабочих копиях),а все что им действительно нужно—это дель- ты изменений и другие бинарные данные репозитория. Вот это и есть «чистый репозиторий».

**Создайте чистый репозиторий**

Выполните (см. рис. 129)

![Рисунок 129. Создание репозитория](https://i.imgur.com/B0C8883.png)

Рисунок 129. Создание репозитория

Сейчас мы находимся в рабочем каталоге

Как правило, репозитории, оканчивающиеся на .git являются чистыми репозиториями. Мы видим, что в репозитории hello.git нет рабочего каталога. По сути, это есть не что иное, как каталог.git нечистого репозитория.

**Добавление удаленного репозитория**

Давайте добавим репозиторий hello.git к нашему оригинальному репозиторию (см. рис. 130)

![Рисунок 130. Добавление репозитория](https://i.imgur.com/Re3hylu.png)

Рисунок 130. Добавление репозитория

**Отправка изменений**

Так как чистые репозитории, как правило, расшариваются на каком-нибудь сетевом сервере, нам необходимо отправить наши изменения в другие репозитории. Начнем с создания изменения для отправки.Отредактируйте файл README.md и сделайте коммит (см. рис. 131)

![Рисунок 131. Изменение файла](https://i.imgur.com/D8ezNbB.png)

Рисунок 131. Изменение файла

Выполните (см. рис. 132)

![Рисунок 132. Коммит](https://i.imgur.com/ECAXTTm.png)

Рисунок 132. Коммит

Теперь отправьте изменения в общий репозиторий. Выполните (см. рис. 133)




Общим называется репозиторий,получающий отправленные нами изменения.

38. **Извлечение общих изменений**

Научиться извлекать изменения из общего репозитория.Быстро переключитесь в клонированный репозиторий и извлеките изменения,только что отправленные в общий репозиторий.

Выполните:

cd ../cloned\_hello

Сейчас мы находимся в репозитории cloned\_hello. Выполните:

git remote add shared ../hello.git git branch --track shared master git pull shared master

cat README.md
32











